<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>部署一个属于自己的QQ机器人</title>
      <link href="/2022/06/04/bu-shu-yi-ge-shu-yu-zi-ji-de-qq-ji-qi-ren/"/>
      <url>/2022/06/04/bu-shu-yi-ge-shu-yu-zi-ji-de-qq-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<h1 id="部署一个属于自己的QQ机器人"><a href="#部署一个属于自己的QQ机器人" class="headerlink" title="部署一个属于自己的QQ机器人"></a>部署一个属于自己的QQ机器人</h1><blockquote><p>此文用到的项目</p><ul><li><a href="https://github.com/Mrs4s/MiraiGo">MiraiGo</a></li><li><a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a></li><li><a href="https://github.com/Si-Huan/XZZ">XZZ</a></li></ul></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Python-环境并克隆-XZZ"><a href="#安装-Python-环境并克隆-XZZ" class="headerlink" title="安装 Python 环境并克隆 XZZ"></a>安装 Python 环境并克隆 XZZ</h3><blockquote><p>因为机器人的逻辑部分，也就西 XZZ 是 Python 写的，所以需要 Python 环境</p></blockquote><p>在 ArchLinux 中，安装 python</p><pre class="line-numbers language-none"><code class="language-none">sudo pacman -S python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>克隆 XZZ</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Si-Huan&#x2F;XZZ.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="编译或下载-go-cqhttp"><a href="#编译或下载-go-cqhttp" class="headerlink" title="编译或下载 go-cqhttp"></a>编译或下载 go-cqhttp</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>克隆仓库</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Mrs4s&#x2F;go-cqhttp.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">cd go-cqhttp &amp;&amp; go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>tips: 自备 go 环境</p></blockquote><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>前往 <a href="https://github.com/Mrs4s/go-cqhttp/releases">Releases 页面</a> 下载自己系统对应的版本</p><h3 id="安装并启动-Redis-数据库-（可选）"><a href="#安装并启动-Redis-数据库-（可选）" class="headerlink" title="安装并启动 Redis 数据库 （可选）"></a>安装并启动 Redis 数据库 （可选）</h3><blockquote><p>可选但推荐，不然可能有一些服务无法使用</p></blockquote><p>在 ArchLinux 下</p><pre class="line-numbers language-none"><code class="language-none">sudo pacman -S redissudo systemctl enable redis.service --now<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>tips: 请保持 redis 服务运行在 XZZ 同服务器 6379 端口</p></blockquote><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>我们假设你现在的目录结果如下</p><pre class="line-numbers language-none"><code class="language-none">.├── bot│   └── go-cqhttp└── xzz    ├── exmple.json    ├── main.py    ├── README.md    ├── req.txt    ├── route.py    ├── sample_config.py    ├── test.py    ├── worker    └── zzcore.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>xzz</code> 文件夹下是你第一步克隆的 XZZ</p><p>其中 <code>bot</code> 文件夹下的 <code>go-cqhttp</code> 是你在第一步下载或编译的 go-cqhttp 的可执行文件</p><h3 id="初始化并配置-go-cqhttp"><a href="#初始化并配置-go-cqhttp" class="headerlink" title="初始化并配置 go-cqhttp"></a>初始化并配置 go-cqhttp</h3><p>移步至 <code>bot</code> 文件夹下启动 <code>go-cqhttp</code></p><p>你会看到以下信息，程序会自动退出</p><pre class="line-numbers language-none"><code class="language-none">[2020-08-02 22:25:17] [WARNING]: 尝试加载配置文件 config.json 失败: 文件不存在 [2020-08-02 22:25:17] [INFO]: 默认配置文件已生成, 请编辑 config.json 后重启程序.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在你的目录结果大概是这样</p><pre class="line-numbers language-none"><code class="language-none">.├── bot│   ├── config.json│   ├── data│   ├── go-cqhttp│   └── logs└── xzz    ├── exmple.json    ├── main.py    ├── README.md    ├── req.txt    ├── route.py    ├── sample_config.py    ├── test.py    ├── worker    └── zzcore.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们去编辑 <code>./bot/config.json</code></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;uin&quot;: 1010101010,    &quot;password&quot;: &quot;mima&quot;,    &quot;enable_db&quot;: true,    &quot;access_token&quot;: &quot;token&quot;,    &quot;relogin&quot;: false,    &quot;relogin_delay&quot;: 0,    &quot;http_config&quot;: &#123;        &quot;enabled&quot;: true,        &quot;host&quot;: &quot;127.0.0.1&quot;,        &quot;port&quot;: 5700,        &quot;post_urls&quot;: &#123;&quot;127.0.0.1:5580&quot;:&quot;XZZ&quot;&#125;    &#125;,    &quot;ws_config&quot;: &#123;        &quot;enabled&quot;: false,        &quot;host&quot;: &quot;0.0.0.0&quot;,        &quot;port&quot;: 6700    &#125;,    &quot;ws_reverse_servers&quot;: [&#123;        &quot;enabled&quot;: false,        &quot;reverse_url&quot;: &quot;ws:&#x2F;&#x2F;you_websocket_universal.server&quot;,        &quot;reverse_api_url&quot;: &quot;ws:&#x2F;&#x2F;you_websocket_api.server&quot;,        &quot;reverse_event_url&quot;: &quot;ws:&#x2F;&#x2F;you_websocket_event.server&quot;,        &quot;reverse_reconnect_interval&quot;: 3000    &#125;],    &quot;debug&quot;: false&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要编辑的字段如下</p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>uin</td><td>int64</td><td>登录用 QQ 号</td></tr><tr><td>password</td><td>string</td><td>登录用密码</td></tr><tr><td>access_token</td><td>string</td><td>用于与 XZZ 交互是身份认证</td></tr><tr><td>http_config</td><td>object</td><td>HTTP API 配置，可与上面我给出的配置一致</td></tr><tr><td>ws_config.enable</td><td>bool</td><td>XZZ 不需要用到 ws， 请设置为 false</td></tr><tr><td>ws_reverse_servers.enable</td><td>bool</td><td>同上，设置为 false</td></tr></tbody></table><p>一会配置 XZZ 需要用到的字段有 <code>access_token</code> 、 <code>http_config.host</code> 、 <code>http_config.port</code> 、 <code>http_config.post_urls</code></p><p>如果 <code>go-cqhttp</code> 与 <code>XZZ</code> 没有运行在同一台服务器上请将 <code>http_config.host</code> 设置为 <code>0.0.0.0</code> ，<code>http_config.post_urls</code> 设置为 <code>XZZ</code> 运行时监听的端口</p><p>配置完成之后我们就可以启动 <code>go-cqhttp</code> 了，启动的时候第一次登陆 QQ 可能需要验证码，按字符画输入即可，之后将 <code>go-cqhttp</code> 切到后台，进行下一步。</p><blockquote><p>可以使用如 <strong>screen</strong> 这种工具将 <code>go-cqhttp</code> 挂在后台</p></blockquote><h3 id="配置-XZZ"><a href="#配置-XZZ" class="headerlink" title="配置 XZZ"></a>配置 XZZ</h3><p>移步至 <code>xzz</code> 文件夹下</p><p>创建虚拟环境</p><pre class="line-numbers language-none"><code class="language-none">python -m venv env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活虚拟环境</p><pre class="line-numbers language-none"><code class="language-none">source .&#x2F;env&#x2F;bin&#x2F;activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装依赖</p><pre class="line-numbers language-none"><code class="language-none">pip install -r req.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置 XZZ</p><p>复制一份 <code>sample_config.py</code> 到 <code>config.py</code>，并编辑</p><pre class="line-numbers language-none"><code class="language-none">ALLWORKERS &#x3D; [&#39;bbc&#39;,&#39;bc&#39;,&#39;bing&#39;,&#39;echo&#39;,&#39;mc&#39;,&#39;music&#39;,&#39;ping&#39;,&#39;shi&#39;,&#39;wolfram&#39;,&#39;yiyan&#39;,&#39;help&#39;]APIURL &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5700&#x2F;&#39;AUTHORIZATION &#x3D; &#39;token&#39;PORT &#x3D; 5580BINGKEY &#x3D; &#39;&#39;WOLFRAMALPHAAPPID &#x3D; &#39;&#39;LOLIKEY &#x3D; &#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上必须要配置的有</p><ul><li><code>APIURL</code> 为上文 <strong>go-cqhttp</strong> HTTP API 所在的地址，与上文 <code>http_config.host</code> 、 <code>http_config.port</code> 有关，如果上面这两个和我设置的一样，那么这儿为 <code>127.0.0.1:5700</code></li><li><code>AUTHORIZATION</code> 与上文 <code>access_token</code> 相同，这儿为 <code>token</code></li><li><code>PORT</code> <strong>XZZ</strong> 要监听的端口，这儿设置为 <code>5580</code> ，请保证上文 <code>http_config.post_urls</code> 中的端口与此一致，以便 <strong>go-cqhttp</strong> 可以访问到 <strong>XZZ</strong></li></ul><p>其余参数可选</p><ul><li><code>ALLWORKERS</code> 使用 <code>/help</code> 命令时所列出的项目</li><li><code>BINGKEY</code> 如需要使用 <code>/bing</code> 命令必须添加，申请地址 （以后加）</li><li><code>WOLFRAMALPHAAPPID</code> 如需要使用 <code>/wolfram</code> 命令必须添加，申请地址 （以后加）</li><li><code>LOLIKEY</code> 如需要使用 <code>/pixiv</code> 命令必须添加，申请地址 （以后加）</li></ul><p>配置完毕之后，启动 XZZ</p><pre class="line-numbers language-none"><code class="language-none">python main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和上文 对 go-cqhttp 的处理一样，挂在后台就好了</p><h3 id="测试！"><a href="#测试！" class="headerlink" title="测试！"></a>测试！</h3><p>在群聊发生 <code>/ping</code> ，bot 是不是回复了 <code>Pong</code> 呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> cq-http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel框架的部署</title>
      <link href="/2021/12/15/laravel-kuang-jia-de-bu-shu/"/>
      <url>/2021/12/15/laravel-kuang-jia-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel框架的部署"><a href="#Laravel框架的部署" class="headerlink" title="Laravel框架的部署"></a>Laravel框架的部署</h1><p>1、     Laravel是一套简洁、优雅的php web开发框架。</p><p>2、     是当前比较流行的web开发框架。非常强大：提供了很多工具和功能来满足大型的企业项目开发需求。比如：验证、路由、session、缓存、数据库迁移工具、单元测试 ..</p><p>竞品框架：ThinkPhp、CI、YII</p><p>3、     诞生于美国，泰勒-奥特威尔。基于另一个框架symfony制作出来的，在2011年6月11月。</p><p>4、     框架特点：</p><p>1、单入口：所有的请求都是从同一个地方开始的</p><p>2、MVC模型：Model业务模型层 和 View视图层分离，前后端分离开发。C是控制层。这个一种经典设计模式</p><p>3、ORM模式操作数据库</p><p>5、Laravel框架对php环境要求高。</p><p>安装环境要求</p><p>·   PHP &gt;&#x3D; 5.5.9 [1] </p><p>·   OpenSSL PHP Extension</p><p>·   PDO PHP Extension</p><p>·   Mbstring PHP Extension</p><p>·   Tokenizer PHP Extension</p><h1 id="实操部分："><a href="#实操部分：" class="headerlink" title="实操部分："></a>实操部分：</h1><p>1、     安装nodpad++ 超级本文工具</p><p>目的：辅助我们编辑文档</p><p>2、     安装apache服务器</p><p>目的：帮我们把php程序转换为网站样式，同时让我们可以通过ip的形式访问到该程序项目</p><p>conf&#x2F;httpd.conf配置文件修改</p><p>2.1、修改安装地址（一定要写对自己文件夹名字）：</p><p>Define SRVROOT “C:\web\apache2.4”</p><p>2.2、开启服务器域名（也就是把#干掉）</p><p>ServerName <a href="http://www.example.com/">www.example.com:80</a></p><p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>2.3、以管理员身份打开cmd</p><p>2.4、进入apache的bin目录  </p><p>cd C:\web\apache2.4\bin</p><p>2.5、执行apche服务器的安装命令 </p><p>httpd -k install -n Apache2.4</p><p>​     2.6、找到bin目录下的ApacheMonitor.exe文件双击打开，可以以视图的形式开启、关闭、重启服务器</p><p>​              当然，也可以通过命令开启、关闭、重启服务器</p><p>​              Httpd -k start&#x2F;stop&#x2F;restart</p><p>​     2.7、apache服务器启动的情况下，在浏览器中输入：</p><p>localhost或者127.0.0.1或者本机ip都能访问到项目首页！！</p><p>关于项目首页：你放的什么项目，就能出现什么项目！！项目默认放在htdocs文件夹里面。</p><p>Apache服务器的意义：安装服务器并启动，就表示开启并监听本机的80端口，暴漏给其他服务器访问！！访问谁？访问自己在apache服务器里面部署的项目</p><p>3、     安装php环境（解压缩到c盘的web目录下叫php7.2）</p><p>复制php.ini-devlepoment 重命名为php.ini</p><p>php.ini就是配置文件（以后里面放拓展文件）</p><p>3.1、关联apache和php</p><p>​         就是在apche的配置文件httpd.conf里面，最后一行引入php模块</p><p>​         #引入php模块</p><pre class="line-numbers language-none"><code class="language-none">LoadModule php7_module &quot;C:&#x2F;web&#x2F;php7.2&#x2F;php7apache2_4.dll&quot;&lt;FilesMatch &quot;\.php$&quot;&gt;​     setHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt;PHPIniDir &quot;c:&#x2F;web&#x2F;php7.2&quot;LoadFile &quot;C:&#x2F;web&#x2F;php7.2&#x2F;libssh2.dll&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.2、在apache的htdocs文件夹里面创建test.php文件，里面就写一条php语句：<?php phpinfo() ?></p><p>3.3、打开浏览器访问localhost&#x2F;test.php 就能看见php环境，说明php和apache服务器关联成功！！</p><p>3.4、如果没有php信息，只是显示<?php phpinfo() ?> </p><p>说明  段标签  没开启！！去php的ini配置文件找</p><p>“short_open_tag”设置值为on。然后重启服务器再试试</p><p>3.5、修改httpd.conf的项目首页配置（索引）</p><pre class="line-numbers language-none"><code class="language-none">&lt;IfModule dir_module&gt;​    DirectoryIndex index.html index.php&lt;&#x2F;IfModule&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     3.6、去php的配置文件php.ini里面修改拓展模块的文件夹位置！！同时，开启crul\gb2\openssl拓展</p><p>; 先去指定window系统下面，我们php模块文件夹在哪</p><p>extension_dir &#x3D; “C:&#x2F;web&#x2F;php7.2&#x2F;ext”</p><p>; 该文件夹下面有很多.dll结尾的拓展模块供我们使用，我们选择使用谁</p><p>extension&#x3D;curl</p><p>extension&#x3D;gd2</p><p>extension&#x3D;openssl</p><p>4、     安装mysql数据库</p><p>4.1、解压缩mysql.5.7.24.zip到c盘以外的盘</p><p>4.2、进入mysql的bin目录，将bin目录地址配置到环境变量（直接放到  “系统路径-path”  里面）</p><p>4.3、以管理员身份打开cmd，执行命令 mysqld –initialize</p><p>​         卡顿几秒后会在mysql里面生成一个data文件夹，</p><p>用来装数据库的。里面有 计算机名.err 的文件包含一个随机生成的密码，大概在第6行</p><p>​     4.4、继续执行命令  mysqld -install 安装mysql服务</p><p>​     4.5、继续执行命令  net start mysql  启动mysql服务器</p><p>​     4.6、安装并启动mysql服务后，通过命令</p><p>mysql -uroot -p进入mysql系统，修改用户密码</p><p>​     4.7、执行命令 set password for root@localhost &#x3D; password(‘123456’);  即可</p><p>5、     配置虚拟机（修改hosts文件）</p><p>5.1、修改c:&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts 配置文件</p><p>5.2、在最下方添加一行 127.0.0.1  laravel.test</p><p>5.3、给与管理员身份保存，然后浏览器访问laravel.test检查能不能看到和输入127.0.0.1一样的网页内容</p><p>（hosts文件用于配置域名与ip地址之间的解析关系，当浏览器请求的域名在hosts文件内存在的时候，会优先使用该“解析记录”  当该域名的解析记录不存在的时候，才会去互联网上查找、解析）</p><p>5.4、通知apache启用虚拟主机辅助配置文件</p><p>去掉Include conf&#x2F;extra&#x2F;httpd-vhosts.conf的注释#</p><p>表示要启用虚拟机的辅助配置文件</p><p>5.5、修改conf&#x2F;extra&#x2F;httpd-vhosts.conf配置文件</p><pre class="line-numbers language-none"><code class="language-none">    &lt;VirtualHost *:80&gt;​    DocumentRoot &quot;C:&#x2F;web&#x2F;apache2.4&#x2F;htdocs&quot;​    ServerName localhost&lt;&#x2F;VirtualHost&gt;&lt;VirtualHost *:80&gt;​    DocumentRoot &quot;C:&#x2F;web&#x2F;www&#x2F;laravel&#x2F;public&quot;​    ServerName laravel.test&lt;&#x2F;VirtualHost&gt;&lt;Directory &quot;C:&#x2F;web&#x2F;www&quot;&gt; Options -indexes AllowOverride All Require local&lt;&#x2F;Directory&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     5.6、记得去创建配置里写的文件夹！！</p><p>​         DocumentRoot “C:&#x2F;web&#x2F;www&#x2F;laravel&#x2F;public”</p><p>​     5.7、在public文件夹下面创建index.html 随便写点什么，然后输入laravel.test看看能不能访问到public文件夹下的首页index.html</p><p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>6、     安装composer</p><p>6.1、介绍：composer是php用来管理依赖关系的工具库。</p><p>只需要在项目配置中声明所需依赖的库，composer就会自动安装这些依赖库文件。</p><p>6.2、傻瓜式下一步，进行安装。安装完成后，cmd输入composer</p><p>6.3、安装编程环境：Visual studio code 简称vsCode</p><p>​     它是微软公司开发的一款免费、开源、高性能、跨平台的代码编辑器。</p><p>​     安装完成后，在左侧栏找到第5个图标—extension </p><p>进入拓展插件的安装，安装chinaese中文简体语言。</p><p>​     </p><p>7、     利用composer安装laravel框架</p><p>7.1、补上laravel需要的拓展：</p><p>extension&#x3D;pdo_mysql</p><p>extension&#x3D;mbstring</p><p>7.2、利用composer安装laravel框架，命令如下：</p><p>​     Laravel框架的国外镜像很难下载，所以转用国内阿里云或者华为云镜像服务器：</p><p>阿里云：</p><pre class="line-numbers language-none"><code class="language-none">composer config -g repo.packagist composer &lt;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装laravel：</p><pre class="line-numbers language-none"><code class="language-none">composer create-project --prefer-distlaravel&#x2F;laravel laravel 5.8.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装成功截图：</p><p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>访问Laravel框架默认index</p><p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门网络爬虫</title>
      <link href="/2021/07/13/python-ru-men-wang-luo-pa-chong/"/>
      <url>/2021/07/13/python-ru-men-wang-luo-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="Python入门网络爬虫"><a href="#Python入门网络爬虫" class="headerlink" title="Python入门网络爬虫"></a>Python入门网络爬虫</h1><p>Python学习网络爬虫主要分3个大的版块：<strong>抓取</strong>，<strong>分析</strong>，<strong>存储</strong>  </p><p>另外，比较常用的爬虫框架<a href="http://scrapy.org/">Scrapy</a>，这里最后也详细介绍一下。    </p><p>简单来说这段过程发生了以下四个步骤：</p><ul><li>查找域名对应的IP地址。</li><li>向IP对应的服务器发送请求。</li><li>服务器响应请求，发回网页内容。</li><li>浏览器解析网页内容。</li></ul><p>网络爬虫要做的，简单来说，就是实现浏览器的功能。通过指定url，直接返回给用户所需要的数据，而不需要一步步人工去操纵浏览器获取。</p><h2 id="抓取"><a href="#抓取" class="headerlink" title="抓取"></a>抓取</h2><p>这一步，你要明确要得到的内容是什么？是HTML源码，还是Json格式的字符串等。  </p><h4 id="1-最基本的抓取"><a href="#1-最基本的抓取" class="headerlink" title="1. 最基本的抓取"></a>1. 最基本的抓取</h4><p>抓取大多数情况属于get请求，即直接从对方服务器上获取数据。  </p><p>首先，Python中自带urllib及urllib2这两个模块，基本上能满足一般的页面抓取。另外，<a href="https://github.com/kennethreitz/requests">requests</a>也是非常有用的包，与此类似的，还有<a href="https://github.com/jcgregorio/httplib2">httplib2</a>等等。    </p><pre class="line-numbers language-none"><code class="language-none">Requests：import requestsresponse &#x3D; requests.get(url)content &#x3D; requests.get(url).contentprint &quot;response headers:&quot;, response.headersprint &quot;content:&quot;, contentUrllib2：import urllib2response &#x3D; urllib2.urlopen(url)content &#x3D; urllib2.urlopen(url).read()print &quot;response headers:&quot;, response.headersprint &quot;content:&quot;, contentHttplib2：import httplib2http &#x3D; httplib2.Http()response_headers, content &#x3D; http.request(url, &#39;GET&#39;)print &quot;response headers:&quot;, response_headersprint &quot;content:&quot;, content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，对于带有查询字段的url，get请求一般会将来请求的数据附在url之后，以?分割url和传输数据，多个参数用&amp;连接。  </p><pre class="line-numbers language-none"><code class="language-none">data &#x3D; &#123;&#39;data1&#39;:&#39;XXXXX&#39;, &#39;data2&#39;:&#39;XXXXX&#39;&#125;Requests：data为dict，jsonimport requestsresponse &#x3D; requests.get(url&#x3D;url, params&#x3D;data)Urllib2：data为stringimport urllib, urllib2    data &#x3D; urllib.urlencode(data)full_url &#x3D; url+&#39;?&#39;+dataresponse &#x3D; urllib2.urlopen(full_url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-对于登陆情况的处理"><a href="#2-对于登陆情况的处理" class="headerlink" title="2. 对于登陆情况的处理"></a>2. 对于登陆情况的处理</h3><p><strong>2.1 使用表单登陆</strong>  </p><p>这种情况属于post请求，即先向服务器发送表单数据，服务器再将返回的cookie存入本地。  </p><pre class="line-numbers language-none"><code class="language-none">data &#x3D; &#123;&#39;data1&#39;:&#39;XXXXX&#39;, &#39;data2&#39;:&#39;XXXXX&#39;&#125;Requests：data为dict，jsonimport requestsresponse &#x3D; requests.post(url&#x3D;url, data&#x3D;data)Urllib2：data为stringimport urllib, urllib2    data &#x3D; urllib.urlencode(data)req &#x3D; urllib2.Request(url&#x3D;url, data&#x3D;data)response &#x3D; urllib2.urlopen(req)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.2 使用cookie登陆</strong>  </p><p>使用cookie登陆，服务器会认为你是一个已登陆的用户，所以就会返回给你一个已登陆的内容。因此，需要验证码的情况可以使用带验证码登陆的cookie解决。  </p><pre class="line-numbers language-none"><code class="language-none">import requestsrequests_session &#x3D; requests.session() response &#x3D; requests_session.post(url&#x3D;url_login, data&#x3D;data) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若存在验证码，此时采用response &#x3D; requests_session.post(url&#x3D;url_login, data&#x3D;data)是不行的，做法应该如下：  </p><pre class="line-numbers language-none"><code class="language-none">response_captcha &#x3D; requests_session.get(url&#x3D;url_login, cookies&#x3D;cookies)response1 &#x3D; requests.get(url_login) # 未登陆response2 &#x3D; requests_session.get(url_login) # 已登陆，因为之前拿到了Response Cookie！response3 &#x3D; requests_session.get(url_results) # 已登陆，因为之前拿到了Response Cookie！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-对于反爬虫机制的处理"><a href="#3-对于反爬虫机制的处理" class="headerlink" title="3. 对于反爬虫机制的处理"></a>3. 对于反爬虫机制的处理</h3><p><strong>3.1 使用代理</strong> </p><p>适用情况：限制IP地址情况，也可解决由于“频繁点击”而需要输入验证码登陆的情况。  </p><p>这种情况最好的办法就是维护一个代理IP池，网上有很多免费的代理IP，良莠不齐，可以通过筛选找到能用的。对于“频繁点击”的情况，我们还可以通过限制爬虫访问网站的频率来避免被网站禁掉。</p><pre class="line-numbers language-none"><code class="language-none">proxies &#x3D; &#123;&#39;http&#39;:&#39;http:&#x2F;&#x2F;XX.XX.XX.XX:XXXX&#39;&#125;Requests：import requestsresponse &#x3D; requests.get(url&#x3D;url, proxies&#x3D;proxies)Urllib2：import urllib2proxy_support &#x3D; urllib2.ProxyHandler(proxies)opener &#x3D; urllib2.build_opener(proxy_support, urllib2.HTTPHandler)urllib2.install_opener(opener) # 安装opener，此后调用urlopen()时都会使用安装过的opener对象response &#x3D; urllib2.urlopen(url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2 时间设置</strong> </p><p>适用情况：限制频率情况。 </p><p>Requests，Urllib2都可以使用time库的sleep()函数：</p><pre class="line-numbers language-none"><code class="language-none">import timetime.sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3.3 伪装成浏览器，或者反“反盗链”</strong>  </p><p>有些网站会检查你是不是真的浏览器访问，还是机器自动访问的。这种情况，加上User-Agent，表明你是浏览器访问即可。有时还会检查是否带Referer信息还会检查你的Referer是否合法，一般再加上Referer。</p><pre class="line-numbers language-none"><code class="language-none">headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;XXXXX&#39;&#125; # 伪装成浏览器访问，适用于拒绝爬虫的网站headers &#x3D; &#123;&#39;Referer&#39;:&#39;XXXXX&#39;&#125;headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;XXXXX&#39;, &#39;Referer&#39;:&#39;XXXXX&#39;&#125;Requests：response &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)Urllib2：import urllib, urllib2   req &#x3D; urllib2.Request(url&#x3D;url, headers&#x3D;headers)response &#x3D; urllib2.urlopen(req)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-对于断线重连"><a href="#4-对于断线重连" class="headerlink" title="4. 对于断线重连"></a>4. 对于断线重连</h3><p>不多说。</p><pre class="line-numbers language-none"><code class="language-none">def multi_session(session, *arg):retryTimes &#x3D; 20while retryTimes&gt;0:try:return session.post(*arg)except:print &#39;.&#39;,retryTimes -&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者  </p><pre class="line-numbers language-none"><code class="language-none">def multi_open(opener, *arg):retryTimes &#x3D; 20while retryTimes&gt;0:try:return opener.open(*arg)except:print &#39;.&#39;,retryTimes -&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就可以使用multi_session或multi_open对爬虫抓取的session或opener进行保持。    </p><h3 id="5-多进程抓取"><a href="#5-多进程抓取" class="headerlink" title="5. 多进程抓取"></a>5. 多进程抓取</h3><h3 id="6-对于Ajax请求的处理"><a href="#6-对于Ajax请求的处理" class="headerlink" title="6. 对于Ajax请求的处理"></a>6. 对于Ajax请求的处理</h3><p>对于“加载更多”情况，使用Ajax来传输很多数据。</p><p>它的工作原理是：从网页的url加载网页的源代码之后，会在浏览器里执行JavaScript程序。这些程序会加载更多的内容，“填充”到网页里。这就是为什么如果你直接去爬网页本身的url，你会找不到页面的实际内容。  </p><p>这里，若使用Google Chrome分析”请求“对应的链接(方法：右键→审查元素→Network→清空，点击”加载更多“，出现对应的GET链接寻找Type为text&#x2F;html的，点击，查看get参数或者复制Request URL)，循环过程。  </p><ul><li>如果“请求”之前有页面，依据上一步的网址进行分析推导第1页。以此类推，抓取抓Ajax地址的数据。  </li><li>对返回的json格式数据(str)进行正则匹配。json格式数据中，需从’\uxxxx’形式的unicode_escape编码转换成u’\uxxxx’的unicode编码。</li></ul><h3 id="7-自动化测试工具Selenium"><a href="#7-自动化测试工具Selenium" class="headerlink" title="7. 自动化测试工具Selenium"></a>7. 自动化测试工具Selenium</h3><p>Selenium是一款自动化测试工具。它能实现操纵浏览器，包括字符填充、鼠标点击、获取元素、页面切换等一系列操作。总之，凡是浏览器能做的事，Selenium都能够做到。</p><h3 id="8-验证码识别"><a href="#8-验证码识别" class="headerlink" title="8. 验证码识别"></a>8. 验证码识别</h3><p>对于网站有验证码的情况，我们有三种办法：  </p><ul><li>使用代理，更新IP。</li><li>使用cookie登陆。</li><li>验证码识别。</li></ul><p>使用代理和使用cookie登陆之前已经讲过，下面讲一下验证码识别。  </p><p>可以利用开源的Tesseract-OCR系统进行验证码图片的下载及识别，将识别的字符传到爬虫系统进行模拟登陆。当然也可以将验证码图片上传到打码平台上进行识别。如果不成功，可以再次更新验证码识别，直到成功为止。  </p><p><strong>爬取有两个需要注意的问题：</strong></p><ul><li>如何监控一系列网站的更新情况，也就是说，如何进行增量式爬取？</li><li>对于海量数据，如何实现分布式爬取？</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>抓取之后就是对抓取的内容进行分析，你需要什么内容，就从中提炼出相关的内容来。  </p><p>常见的分析工具有<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式</a>，<a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a>，<a href="http://lxml.de/">lxml</a>等等。  </p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>分析出我们需要的内容之后，接下来就是存储了。  </p><p>我们可以选择存入文本文件，也可以选择存入<a href="http://www.mysql.com/">MySQL</a>或<a href="https://www.mongodb.org/">MongoDB</a>数据库等。  </p><p><strong>存储有两个需要注意的问题：</strong></p><ul><li>如何进行网页去重？</li><li>内容以什么形式存储？</li></ul><h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><p>Scrapy是一个基于Twisted的开源的Python爬虫框架，在工业中应用非常广泛。  </p><h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h2><p>好的网络爬虫，首先需要遵守<strong>Robots协议</strong>。Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p><p>在网站根目录下放一个robots.txt文本文件（如 <a href="https://www.taobao.com/robots.txt">https://www.taobao.com/robots.txt</a> ），里面可以指定不同的网络爬虫能访问的页面和禁止访问的页面，指定的页面由正则表达式表示。网络爬虫在采集这个网站之前，首先获取到这个robots.txt文本文件，然后解析到其中的规则，然后根据规则来采集网站的数据。</p><h3 id="1-Robots协议规则"><a href="#1-Robots协议规则" class="headerlink" title="1. Robots协议规则"></a>1. Robots协议规则</h3><pre class="line-numbers language-none"><code class="language-none">User-agent: 指定对哪些爬虫生效Disallow: 指定不允许访问的网址Allow: 指定允许访问的网址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意: 一个英文要大写，冒号是英文状态下，冒号后面有一个空格，”&#x2F;“代表整个网站</p><h3 id="2-Robots协议举例"><a href="#2-Robots协议举例" class="headerlink" title="2. Robots协议举例"></a>2. Robots协议举例</h3><pre class="line-numbers language-none"><code class="language-none">禁止所有机器人访问User-agent: *Disallow: &#x2F;允许所有机器人访问User-agent: *Disallow: 禁止特定机器人访问User-agent: BadBotDisallow: &#x2F;允许特定机器人访问User-agent: GoodBotDisallow: 禁止访问特定目录User-agent: *Disallow: &#x2F;images&#x2F;仅允许访问特定目录User-agent: *Allow: &#x2F;images&#x2F;Disallow: &#x2F;禁止访问特定文件User-agent: *Disallow: &#x2F;*.html$仅允许访问特定文件User-agent: *Allow: &#x2F;*.html$Disallow: &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs给定路由连接MySql</title>
      <link href="/2020/12/18/nodejs-gei-ding-lu-you-lian-jie-mysql/"/>
      <url>/2020/12/18/nodejs-gei-ding-lu-you-lian-jie-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Node-js给定路由连接MySql数据库"><a href="#使用Node-js给定路由连接MySql数据库" class="headerlink" title="使用Node.js给定路由连接MySql数据库"></a>使用Node.js给定路由连接MySql数据库</h1><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p><strong>输入初始化命令</strong>：<code>npm init –y</code></p><p><strong>安装express 模块</strong>：<code>npm i express</code></p><p><strong>监测文件修改</strong>：<code>npm i nodemon -g</code></p><p><strong>安装mysql模块</strong>：<code>npm i mysql</code></p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h2 id="创建连接数据库的js文件（名称自定，如：sql-js）："><a href="#创建连接数据库的js文件（名称自定，如：sql-js）：" class="headerlink" title="创建连接数据库的js文件（名称自定，如：sql.js）："></a>创建连接数据库的js文件（名称自定，如：sql.js）：</h2><pre class="line-numbers language-none"><code class="language-none">const express &#x3D;require(&#39;express&#39;)const app&#x3D;express()const mysql&#x3D;require(&#39;mysql&#39;) const con &#x3D; mysql.createConnection(&#123;​    host: &#39;127.0.0.1&#39;,​    user: &#39;root&#39;,​    password: &#39;123&#39;,​    port: &#39;3306&#39;,​    database: &#39;test&#39;,​    insecureAuth: true&#125;)con.connect(e&#x3D;&gt;&#123;​         console.log(e,&quot;数据库连接成功！&quot;);&#125;)  app.get(&#39;&#x2F;user&#39;,(req,res)&#x3D;&gt;&#123;​         let sql&#x3D;&#96;select Name,PhoneNum from miao where sex&#x3D;0&#96;​         con.query(sql,(e,resu)&#x3D;&gt;&#123;​                   res.send(resu)​         &#125;)&#125;) app.listen(1314,()&#x3D;&gt;&#123;​         console.log(&#39;1314端口开启成功&#39;);&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h5 id="在浏览器访问-localhost-1314-x2F-user-即可访问到给定条件下的数据库的内容了"><a href="#在浏览器访问-localhost-1314-x2F-user-即可访问到给定条件下的数据库的内容了" class="headerlink" title="在浏览器访问 localhost:1314&#x2F;user 即可访问到给定条件下的数据库的内容了~"></a>在浏览器访问 localhost:1314&#x2F;user 即可访问到给定条件下的数据库的内容了~</h5>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个相见恨晚的Linux命令</title>
      <link href="/2020/11/07/ji-ge-xiang-jian-hen-wan-de-linux-ming-ling/"/>
      <url>/2020/11/07/ji-ge-xiang-jian-hen-wan-de-linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="几个相见恨晚的-Linux-命令"><a href="#几个相见恨晚的-Linux-命令" class="headerlink" title="几个相见恨晚的 Linux 命令"></a>几个相见恨晚的 Linux 命令</h1><h3 id="tldr（命令手册）"><a href="#tldr（命令手册）" class="headerlink" title="tldr（命令手册）"></a>tldr（命令手册）</h3><p>作为一个开发人员，会时常用到终端命令，最让人头疼的是记不住繁琐的参数。用谷哥度娘检索效率低下；通过<code>man</code>查看帮助，超长文章不易阅读。</p><p><code>tldr</code>命令正是解决这一痛点，<code>tldr</code>是什么？从它的 GitHub 页翻译说“一个简洁的社区驱动的帮助手册”，这是对它最好的解释，根据二八原则给出命令的常用场景示例，简单易读；存放在 Github 上的命令库接受来自五湖四海的朋友提交的内容，社区驱动。</p><p><code>man</code>命令有更详细的说明，单从实用角度讲，<code>tldr</code>才是王者。</p><pre class="line-numbers language-none"><code class="language-none">fechinwork in ~&#x2F;Desktop at 11:57:57 λ tldr tartarArchiving utility.Often combined with a compression method, such as gzip or bzip.- Create an archive from files:    tar cf target.tar file1 file2 file3- Create a gzipped archive:    tar czf target.tar.gz file1 file2 file3- Extract an archive in a target folder:    tar xf source.tar -C folder- Extract a gzipped archive in the current directory:    tar xzf source.tar.gz- Extract a bzipped archive in the current directory:    tar xjf source.tar.bz2- Create a compressed archive, using archive suffix to determine the compression program:    tar caf target.tar.xz file1 file2 file3- List the contents of a tar file:    tar tvf source.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：支持在进 20 中语言环境下运行，通过<code>tldr --update</code>更新本地命令库。</p><h3 id="tree（树形目录）"><a href="#tree（树形目录）" class="headerlink" title="tree（树形目录）"></a>tree（树形目录）</h3><p>当我们编写项目文档，想更直观的表达项目结构及内容的时候，这个小小的命令就可以派上用场了，它以类似于图像的树状图排列目录和文件。</p><pre class="line-numbers language-none"><code class="language-none">fechinwork in ~&#x2F;work&#x2F;script&#x2F;nginx2mysql at 12:43:10 λ tree -L 2.├── README.md├── config.yml├── libs│   ├── __init__.py│   ├── __init__.pyc│   ├── nginx_log_parser.py│   ├── nginx_log_parser.pyc│   ├── simplemysql.py│   └── simplemysql.pyc├── logs│   └── cdn-2016-06-04.log├── parser.py└── requirements.txt2 directories, 11 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：支持定制层级，过滤内容等各种个性化设置。通过<code>tldr tree</code>查看具体使用示例。添加<code>-N</code>参数解决中文乱码问题。</p><h3 id="rlwrap（历史命令）"><a href="#rlwrap（历史命令）" class="headerlink" title="rlwrap（历史命令）"></a>rlwrap（历史命令）</h3><p>经常使用命令的同学一定有习惯，通过上下按键切换历史命令，但是让人头疼的是<code>telnet</code>命令不支持切换，甚至是退格删除，所以时常遇到如下尴尬场面。莫急，<code>rlwrap</code>便是用来解决这一痛点的。</p><p>通过<code>telnet</code>执行 Dubbo 接口：</p><pre class="line-numbers language-none"><code class="language-none">&gt; telnet 192.168.1.147 23457&gt; invoke com.yinyuetai.yuan.user.api.UserService.get(1) &gt; ^[[A^[[A^[[A^[[B^[[B# 好尴尬~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过<code>telnet</code>连接 memcached 服务器：</p><pre class="line-numbers language-none"><code class="language-none">&gt; telnet 192.168.1.36 11211 &gt; ^[[A^[[A^[[A^[[B^[[B# 好尴尬~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>什么是<code>rlwrap</code>？它是基于 readline 库，实现命令行补全和记录的包装命令。如今交互式输入是最基本的需求，Linux 正是通过 readline 这个库来记录用户的操作，实现交互式输入、自动补全、搜索等功能。对于没有支持 readline 操作的命令，<code>rlwrap</code>就是最好的伙伴了。</p><p>用法：在执行<code>telnet</code>命令前加上 rlwrap 命令即可。</p><pre class="line-numbers language-none"><code class="language-none">fechinwork in ~&#x2F;Documents at 14:43:15 λfechinwork in ~&#x2F;Documents at 14:43:41 λ rlwrap telnet 127.0.0.1 6379Trying 127.0.0.1...Connected to localhost.Escape character is &#39;^]&#39;.set product alpha+OKget prod$-1get product$5alpha<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：除了<code>telnet</code>还有 Oracle 系列命令需要支持 rlwrap 包装装<code>sqlplus</code>、<code>rman</code>、<code>asmcmd</code><br>快捷别名：<code>alias telnet=&#39;rlwrap telnet&#39;</code></p><h3 id="script（记录会话输出）"><a href="#script（记录会话输出）" class="headerlink" title="script（记录会话输出）"></a>script（记录会话输出）</h3><p>很多时候，为了安全和备份，需要对工作内容进行保存。那么，<code>script</code>命令就是隐藏在终端的记录器，它可以记录终端会话的所有内容，形成文件。对于需要工作留痕的同学来说，<code>script</code>便是良药。<br>如何使用，用<code>script</code>启动它，此时它已经开始记录。完事后用<code>exit</code>退出记录，默认生成了一个叫“typescript”的文件。</p><pre class="line-numbers language-none"><code class="language-none">fechinwork in ~ at 13:34:04 λ scriptScript started, output file is typescriptfechinwork in ~ at 13:34:07 λ echo &#39;导演，开始了吗？&#39;导演，开始了吗？fechinwork in ~ at 13:34:27 λ echo &#39;你退出自己看咯，略略~&#39;你退出自己看咯，略略~fechinwork in ~ at 13:34:48 λ exitScript done, output file is typescriptfechinwork in ~ at 13:34:51 λ cat typescriptScript started on Sat Oct 21 13:34:06 2017fechinwork in ~ at 13:34:07 λ echo &#39;导演，开始了吗？&#39;导演，开始了吗？fechinwork in ~ at 13:34:27 λ echo &#39;你退出自己看咯，略略~&#39;你退出自己看咯，略略~fechinwork in ~ at 13:34:48 λ exitScript done on Sat Oct 21 13:34:51 2017<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：<code>script</code>可以在什么场景下使用呢？<br>1、我需要把大批量视频推送到 CDN，耗时一晚上，这时通过<code>script</code>记录执行的日志，第二天对没有推送成功的做单独处理。<br>2、别人远程你的服务器或电脑，安全起见<code>script</code>一下。<br>3、与同事协同工作时，自己工作做了一半，交给另一个人来做，此时发给它你的<code>script</code>，让它接着干。<br>……</p><h3 id="autojump（一键直达）"><a href="#autojump（一键直达）" class="headerlink" title="autojump（一键直达）"></a>autojump（一键直达）</h3><p>最后一个压轴神器，也是我用的最多的命令之一。</p><p>相信多数终端用户使用频率最高的命令是<code>cd</code>、<code>ls</code>, 在我不知道切换到哪里的时候不得不<code>ls</code>确认目录名，如此反复，到达想去的目录可能要经历几次甚至十次以上的 cd，经历了多少风雨才找到我的文件。俗话说“不会偷懒的程序员不是好程序员”，如此饱受挫折那是我们的风格，于是有了 autojump 的诞生，它注定不凡。<br>顾名思义，autojump，自动跳转，而不是切换，因为它可以做到一键直达。</p><pre class="line-numbers language-none"><code class="language-none">fechinwork in ~&#x2F;work&#x2F;script&#x2F;xls2sql at 14:27:24 λ j Des&#x2F;Users&#x2F;fechinwork&#x2F;Desktopfechinwork in ~&#x2F;Desktop at 14:27:27 λ pwd&#x2F;Users&#x2F;fechinwork&#x2F;Desktopfechinwork in ~&#x2F;Desktop at 14:27:31 λ j Docu&#x2F;Users&#x2F;fechinwork&#x2F;Documentsfechinwork in ~&#x2F;Documents at 14:27:41 λ pwd&#x2F;Users&#x2F;fechinwork&#x2F;Documentsfechinwork in ~&#x2F;Documents at 14:27:44 λ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：可以通过<code>j -s</code>命令查看它的数据库，以及数据库中的目录权重。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2020/10/23/ru-he-da-jian-ge-ren-bo-ke/"/>
      <url>/2020/10/23/ru-he-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="所需工具："><a href="#所需工具：" class="headerlink" title="所需工具："></a>所需工具：</h1><ul><li><p>node.js</p></li><li><p>hexo博客框架</p></li><li><p>Typora工具</p></li><li><p>github账号并创建仓库</p></li></ul><h1 id="部署hexo、搭建github仓库："><a href="#部署hexo、搭建github仓库：" class="headerlink" title="部署hexo、搭建github仓库："></a>部署hexo、搭建github仓库：</h1><ul><li><a href="tmd404/github.io">1.详细教程传送门</a></li></ul><h1 id="使用Typora工具并配合hexo命令编写发布博客文章："><a href="#使用Typora工具并配合hexo命令编写发布博客文章：" class="headerlink" title="使用Typora工具并配合hexo命令编写发布博客文章："></a>使用Typora工具并配合hexo命令编写发布博客文章：</h1><ul><li><p><code>$ hexo new &quot;如何搭建个人博客&quot;</code> 创建一篇文章</p></li><li><p>配合使用markdown语法编辑创建的 ”如何搭建个人博客.md“ 文档即可</p></li><li><p>上一步编辑完成后输入命令 <code>$ hexo s</code> 开启本地服务在浏览器访问：localhost:4000 即可</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
